<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-cn">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Redis,Database," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="1. 节点一个 Redis 集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。 连接各个节点的工作可以使用 CLUSTER MEET 命令来完成，该命令的格式如下：CLUSTER MEET &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;。 向一个节">
<meta name="keywords" content="Redis,Database">
<meta property="og:type" content="article">
<meta property="og:title" content="《Redis 设计与实现：集群》">
<meta property="og:url" content="http://yoursite.com/2017/10/07/《Redis-设计与实现：集群》/index.html">
<meta property="og:site_name" content="天歌のBlog">
<meta property="og:description" content="1. 节点一个 Redis 集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。 连接各个节点的工作可以使用 CLUSTER MEET 命令来完成，该命令的格式如下：CLUSTER MEET &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;。 向一个节">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-01-05T08:29:07.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Redis 设计与实现：集群》">
<meta name="twitter:description" content="1. 节点一个 Redis 集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。 连接各个节点的工作可以使用 CLUSTER MEET 命令来完成，该命令的格式如下：CLUSTER MEET &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;。 向一个节">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/07/《Redis-设计与实现：集群》/"/>





  <title>《Redis 设计与实现：集群》 | 天歌のBlog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天歌のBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/07/《Redis-设计与实现：集群》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yongqiang Xiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天歌のBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Redis 设计与实现：集群》</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-07T15:42:23+08:00">
                2017-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-节点"><a href="#1-节点" class="headerlink" title="1. 节点"></a>1. 节点</h2><p>一个 Redis 集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</p>
<p>连接各个节点的工作可以使用 <code>CLUSTER MEET</code> 命令来完成，该命令的格式如下：<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>。</p>
<p>向一个节点 <code>node</code> 发送 <code>CLUSTER MEET</code> 命令，可以让 <code>node</code> 节点与 <code>ip</code> 和 <code>port</code> 所指定的节点进行握手（handshake），当握手成功时，<code>node</code> 节点就会将 <code>ip</code> 和 <code>port</code> 所指定的节点添加到 <code>node</code> 节点当前所在的集群中。</p>
<a id="more"></a>
<h3 id="1-1-启动节点"><a href="#1-1-启动节点" class="headerlink" title="1.1 启动节点"></a>1.1 启动节点</h3><p>一个节点就是一个运行在集群模式下的 Redis 服务器， Redis 服务器在启动时会根据 <code>cluster-enabled</code> 配置选项的是否为 <code>yes</code> 来决定是否开启服务器的集群模式。</p>
<p>节点（运行在集群模式下的 Redis 服务器）会继续使用所有在单机模式中使用的服务器组件。除此之外， 节点会继续使用 <code>redisServer</code> 结构来保存服务器的状态， 使用 <code>redisClient</code> 结构来保存客户端的状态， 至于那些只有在集群模式下才会用到的数据， 节点将它们保存到了 <code>cluster.h/clusterNode</code> 结构， <code>cluster.h/clusterLink</code> 结构， 以及 <code>cluster.h/clusterState</code> 结构里面。</p>
<h3 id="1-2-集群数据结构"><a href="#1-2-集群数据结构" class="headerlink" title="1.2 集群数据结构"></a>1.2 集群数据结构</h3><p><code>clusterNode</code> 结构保存了一个节点的当前状态，比如节点的创建时间，节点的名字，节点当前的配置纪元，节点的 IP 和地址，等等。</p>
<p>每个节点都会使用一个 <code>clusterNode</code> 结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 <code>clusterNode</code> 结构，以此来记录其他节点的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterNode &#123;</span><br><span class="line">    mstime_t ctime; /* Node object creation time. */</span><br><span class="line">    char name[CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */</span><br><span class="line">    int flags;      /* CLUSTER_NODE_... */</span><br><span class="line">    uint64_t configEpoch; /* Last configEpoch observed for this node */</span><br><span class="line">    unsigned char slots[CLUSTER_SLOTS/8]; /* slots handled by this node */</span><br><span class="line">    int numslots;   /* Number of slots handled by this node */</span><br><span class="line">    int numslaves;  /* Number of slave nodes, if this is a master */</span><br><span class="line">    struct clusterNode **slaves; /* pointers to slave nodes */</span><br><span class="line">    struct clusterNode *slaveof; /* pointer to the master node. Note that it</span><br><span class="line">                                    may be NULL even if the node is a slave</span><br><span class="line">                                    if we don&apos;t have the master node in our</span><br><span class="line">                                    tables. */</span><br><span class="line">    mstime_t ping_sent;      /* Unix time we sent latest ping */</span><br><span class="line">    mstime_t pong_received;  /* Unix time we received the pong */</span><br><span class="line">    mstime_t fail_time;      /* Unix time when FAIL flag was set */</span><br><span class="line">    mstime_t voted_time;     /* Last time we voted for a slave of this master */</span><br><span class="line">    mstime_t repl_offset_time;  /* Unix time we received offset for this node */</span><br><span class="line">    mstime_t orphaned_time;     /* Starting time of orphaned master condition */</span><br><span class="line">    long long repl_offset;      /* Last known repl offset for this node. */</span><br><span class="line">    char ip[NET_IP_STR_LEN];  /* Latest known IP address of this node */</span><br><span class="line">    int port;                   /* Latest known port of this node */</span><br><span class="line">    clusterLink *link;          /* TCP/IP link with this node */</span><br><span class="line">    list *fail_reports;         /* List of nodes signaling this as failing */</span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure>
<p><code>clusterNode</code> 结构的 <code>link</code> 属性是一个 <code>clusterLink</code> 结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* clusterLink encapsulates everything needed to talk with a remote node. */</span><br><span class="line">typedef struct clusterLink &#123;</span><br><span class="line">    mstime_t ctime;             /* Link creation time */</span><br><span class="line">    int fd;                     /* TCP socket file descriptor */</span><br><span class="line">    sds sndbuf;                 /* Packet send buffer */</span><br><span class="line">    sds rcvbuf;                 /* Packet reception buffer */</span><br><span class="line">    struct clusterNode *node;   /* Node related to this link if any, or NULL */</span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<p><code>redisClient</code> 结构和 <code>clusterLink</code> 结构都有自己的套接字描述符和输入、输出缓冲区，这两个结构的区别在于，<code>redisClient</code> 结构中的套接字和缓冲区是用于连接客户端的，而 <code>clusterLink</code> 结构中的套接字和缓冲区则是用于连接节点的。</p>
<p>最后，每个节点都保存着一个 <code>clusterState</code> 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态——比如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line">    clusterNode *myself;  /* This node */</span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line">    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */</span><br><span class="line">    int size;             /* Num of master nodes with at least one slot */</span><br><span class="line">    dict *nodes;          /* Hash table of name -&gt; clusterNode structures */</span><br><span class="line">    dict *nodes_black_list; /* Nodes we don&apos;t re-add for a few seconds. */</span><br><span class="line">    clusterNode *migrating_slots_to[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *importing_slots_from[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    /* The following fields are used to take the slave state on elections. */</span><br><span class="line">    mstime_t failover_auth_time; /* Time of previous or next election. */</span><br><span class="line">    int failover_auth_count;    /* Number of votes received so far. */</span><br><span class="line">    int failover_auth_sent;     /* True if we already asked for votes. */</span><br><span class="line">    int failover_auth_rank;     /* This slave rank for current auth request. */</span><br><span class="line">    uint64_t failover_auth_epoch; /* Epoch of the current election. */</span><br><span class="line">    int cant_failover_reason;   /* Why a slave is currently not able to</span><br><span class="line">                                   failover. See the CANT_FAILOVER_* macros. */</span><br><span class="line">    /* Manual failover state in common. */</span><br><span class="line">    mstime_t mf_end;            /* Manual failover time limit (ms unixtime).</span><br><span class="line">                                   It is zero if there is no MF in progress. */</span><br><span class="line">    /* Manual failover state of master. */</span><br><span class="line">    clusterNode *mf_slave;      /* Slave performing the manual failover. */</span><br><span class="line">    /* Manual failover state of slave. */</span><br><span class="line">    long long mf_master_offset; /* Master offset the slave needs to start MF</span><br><span class="line">                                   or zero if stil not received. */</span><br><span class="line">    int mf_can_start;           /* If non-zero signal that the manual failover</span><br><span class="line">                                   can start requesting masters vote. */</span><br><span class="line">    /* The followign fields are used by masters to take state on elections. */</span><br><span class="line">    uint64_t lastVoteEpoch;     /* Epoch of the last vote granted. */</span><br><span class="line">    int todo_before_sleep; /* Things to do in clusterBeforeSleep(). */</span><br><span class="line">    long long stats_bus_messages_sent;  /* Num of msg sent via cluster bus. */</span><br><span class="line">    long long stats_bus_messages_received; /* Num of msg rcvd via cluster bus.*/</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-CLUSTER-MEET-命令的实现"><a href="#1-3-CLUSTER-MEET-命令的实现" class="headerlink" title="1.3 CLUSTER MEET 命令的实现"></a>1.3 CLUSTER MEET 命令的实现</h3><p>通过向节点 A 发送 CLUSTER MEET 命令，客户端可以让接收命令的节点 A 将另一个节点 B 添加到节点 A 当前所在的集群里面：<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>。</p>
<p>收到命令的节点 A 将与节点 B 进行握手（handshake），以此来确认彼此的存在，并为将来的进一步通信打好基础：</p>
<ol>
<li>节点 A 会为节点 B 创建一个 <code>clusterNode</code> 结构，并将该结构添加到自己的 <code>clusterState.nodes</code> 字典里面。</li>
<li>之后，节点 A 将根据 <code>CLUSTER MEET</code> 命令给定的 IP 地址和端口号， 向节点 B 发送一条 <code>MEET</code> 消息（message）。</li>
<li>如果一切顺利，节点 B 将接收到节点 A 发送的 <code>MEET</code> 消息，节点 B 会为节点 A 创建一个 <code>clusterNode</code> 结构，并将该结构添加到自己的 <code>clusterState.nodes</code> 字典里面。</li>
<li>之后，节点 B 将向节点 A 返回一条 <code>PONG</code> 消息。</li>
<li>如果一切顺利，节点 A 将接收到节点 B 返回的 <code>PONG</code> 消息，通过这条 <code>PONG</code> 消息节点 A 可以知道节点 B 已经成功地接收到了自己发送的 <code>MEET</code> 消息。</li>
<li>之后，节点 A 将向节点 B 返回一条 <code>PING</code> 消息。</li>
<li>如果一切顺利，节点 B 将接收到节点 A 返回的 <code>PING</code> 消息，通过这条 <code>PING</code> 消息节点 B 可以知道节点 A 已经成功地接收到了自己返回的 <code>PONG</code> 消息，握手完成。</li>
</ol>
<p>之后，节点 A 会将节点 B 的信息通过 Gossip 协议传播给集群中的其他节点，让其他节点也与节点 B 进行握手，最终，经过一段时间之后，节点 B 会被集群中的所有节点认识。</p>
<h2 id="2-槽指派"><a href="#2-槽指派" class="headerlink" title="2. 槽指派"></a>2. 槽指派</h2><p>Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。 </p>
<p>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p>
<p>通过向节点发送 <code>CLUSTER ADDSLOTS</code> 命令，我们可以将一个或多个槽指派（assign）给节点负责：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot …]</span><br></pre></td></tr></table></figure>
<h3 id="2-1-记录节点的槽指派信息"><a href="#2-1-记录节点的槽指派信息" class="headerlink" title="2.1 记录节点的槽指派信息"></a>2.1 记录节点的槽指派信息</h3><p><code>clusterNode</code> 结构的 <code>slots</code> 属性和 <code>numslot</code> 属性记录了节点负责处理哪些槽：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> numslots;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>slots</code> 属性是一个二进制位数组（bit array），这个数组的长度为 16384/8=2048 个字节，共包含 16384 个二进制位。</p>
<p>Redis 以 0 为起始索引，16383 为终止索引，对 slots 数组中的 16384 个二进制位进行编号，并根据索引 <code>i</code> 上的二进制位的值来判断节点是否负责处理槽 <code>i</code>：</p>
<ul>
<li>如果 <code>slots</code> 数组在索引 <code>i</code> 上的二进制位的值为 1，那么表示节点负责处理槽 <code>i</code>；</li>
<li>如果 <code>slots</code> 数组在索引 <code>i</code> 上的二进制位的值为 0，那么表示节点不负责处理槽 <code>i</code>；</li>
</ul>
<p>因为取出和设置 <code>slots</code> 数组中的任意一个二进制位的值的复杂度仅为 $O(1)$，所以对于一个给定节点的 <code>slots</code> 数组来说，程序检查节点是否负责处理某个槽，又或者将某个槽指派给节点负责，这两个动作的复杂度都是 $O(1)$。</p>
<p>至于 <code>numslots</code> 属性则记录节点负责处理的槽的数量，也即是 <code>slots</code> 数组中值为 1 的二进制位的数量。</p>
<h3 id="2-2-传播节点的槽指派信息"><a href="#2-2-传播节点的槽指派信息" class="headerlink" title="2.2 传播节点的槽指派信息"></a>2.2 传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在 <code>clusterNode</code> 结构的 <code>slots</code> 属性和 <code>numslots</code> 属性之外，它还会将自己的 <code>slots</code> 数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。</p>
<p>当节点 A 通过消息从节点 B 那里接收到节点 B 的 <code>slots</code> 数组时，节点 A 会在自己的 <code>clusterState.nodes</code> 字典中查找节点 B 对应的 <code>clusterNode</code> 结构，并对结构中的 <code>slots</code> 数组进行保存或者更新。</p>
<p>因为集群中的每个节点都会将自己的 <code>slots</code> 数组通过消息发送给集群中的其他节点，并且每个接收到 <code>slots</code> 数组的节点都会将数组保存到相应节点的 <code>clusterNode</code> 结构里面，因此，集群中的每个节点都会知道数据库中的 16384 个槽分别被指派给了集群中的哪些节点。</p>
<h3 id="2-3-记录集群所有槽的指派信息"><a href="#2-3-记录集群所有槽的指派信息" class="headerlink" title="2.3 记录集群所有槽的指派信息"></a>2.3 记录集群所有槽的指派信息</h3><p><code>clusterState</code> 结构中的 <code>slots</code> 数组记录了集群中所有 16384 个槽的指派信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line"></span><br><span class="line">	// ...</span><br><span class="line"></span><br><span class="line">	clusterNode *slots[16384];</span><br><span class="line"></span><br><span class="line">	// ...</span><br><span class="line">	</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p><code>slots</code> 数组包含了 16384 个项，每个数组项都是一个指向 <code>clusterNode</code> 结构的指针：</p>
<ul>
<li>如果 <code>slots[i]</code> 指针指向 NULL，那么表示槽 <code>i</code> 尚未指派给任何节点。</li>
<li>如果 <code>slots[i]</code> 指针指向一个 <code>clusterNode</code> 结构，那么表示槽 <code>i</code> 已经指派给了 <code>clusterNode</code> 结构所代表的节点。</li>
</ul>
<p>如果只将槽指派信息保存在各个节点的 <code>clusterNode.slots</code> 数组里，会出现一些无法高效地解决的问题，而 <code>clusterState.slots</code> 数组的存在解决了这些问题：</p>
<ul>
<li>如果节点只使用 <code>clusterNode.slots</code> 数组来记录槽的指派信息，那么为了知道槽 <code>i</code> 是否已经被指派，或者槽 <code>i</code> 被指派给了哪个节点，程序需要遍历 <code>clusterState.nodes</code> 字典中的所有 <code>clusterNode</code> 结构，检查这些结构的 <code>slots</code> 数组，直到找到负责处理槽 <code>i</code> 的节点为止，这个过程的复杂度为 $O(N)$，其中 $N$ 为 <code>clusterState.nodes</code> 字典保存的 <code>clusterNode</code> 结构的数量。</li>
<li>而通过将所有槽的指派信息保存在 <code>clusterState.slots</code> 数组里面，程序要检查槽 <code>i</code> 是否已经被指派，又或者取得负责处理槽 <code>i</code> 的节点，只需要访问 <code>clusterState.slots[i]</code> 的值即可，这个操作的复杂度仅为 $O(1)$。</li>
</ul>
<p>要说明的一点是，虽然 <code>clusterState.slots</code> 数组中记录了集群中所有槽的指派信息，但使用 <code>clusterNode</code> 结构的 <code>slots</code> 数组来记录单个节点的槽指派信息仍然是有必要的：</p>
<ul>
<li>因为当程序需要将某个节点的槽指派信息通过消息发送给其他节点时，程序只需要将相应节点的 <code>clusterNode.slots</code> 数组整个发送出去就可以了。</li>
<li>另一方面，如果 Redis 不使用 <code>clusterNode.slots</code> 数组，而单独使用 <code>clusterState.slots</code> 数组的话，那么每次要将节点 A 的槽指派信息传播给其他节点时，程序必须先遍历整个 <code>clusterState.slots</code> 数组，记录节点 A 负责处理哪些槽，然后才能发送节点 A 的槽指派信息，这比直接发送 <code>clusterNode.slots</code> 数组要麻烦和低效得多。</li>
</ul>
<p><code>clusterState.slots</code> 数组记录了集群中所有槽的指派信息，而 <code>clusterNode.slots</code> 数组只记录了 <code>clusterNode</code> 结构所代表的节点的槽指派信息，这是两个 <code>slots</code> 数组的关键区别所在。</p>
<h3 id="2-4-CLUSTER-ADDSLOTS命令的实现"><a href="#2-4-CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="2.4 CLUSTER ADDSLOTS命令的实现"></a>2.4 CLUSTER ADDSLOTS命令的实现</h3><p><code>CLUSTER ADDSLOTS</code> 命令接受一个或多个槽作为参数，并将所有输入的槽指派给接收该命令的节点负责：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</span><br></pre></td></tr></table></figure>
<p><code>CLUSTER ADDSLOTS</code> 命令的实现可以用以下伪代码来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def CLUSTER_ADDSLOTS(*all_input_slots):</span><br><span class="line">	</span><br><span class="line">	# 遍历所有输入槽，检查它们是否都是未指派槽</span><br><span class="line">	for i in all_input_slots:</span><br><span class="line"></span><br><span class="line">	# 如果有哪怕一个槽已经被指派给了某个节点</span><br><span class="line">	# 那么向客户端返回错误，并终止命令执行</span><br><span class="line">	if clusterState.slots[i] != NULL:</span><br><span class="line">		reply_error()</span><br><span class="line">		return</span><br><span class="line"></span><br><span class="line">	# 如果所有输入槽都是未指派槽</span><br><span class="line">	# 那么再次遍历所有输入槽，将这些槽指派给当前节点</span><br><span class="line">	for i in all_input_slots:</span><br><span class="line"></span><br><span class="line">		# 设置clusterState结构的slots数组</span><br><span class="line">		# 将slots[i]的指针指向代表当前节点的clusterNode结构</span><br><span class="line">		clusterState.slots[i] = clusterState.myself</span><br><span class="line"></span><br><span class="line">		# 访问代表当前节点的clusterNode结构的slots数组</span><br><span class="line">		# 将数组在索引i上的二进制位设置为 1</span><br><span class="line">		setSlotBit(clusterState.myself.slots, i)</span><br></pre></td></tr></table></figure>
<p>最后，在 <code>CLUSTER ADDSLOTS</code> 命令执行完毕之后，节点会通过发送消息告知集群中的其他节点，自己目前正在负责处理哪些槽。</p>
<h2 id="3-在集群中执行命令"><a href="#3-在集群中执行命令" class="headerlink" title="3. 在集群中执行命令"></a>3. 在集群中执行命令</h2><p>在对数据库中的 16384 个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。</p>
<p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：</p>
<ul>
<li>如果键所在的槽正好指派了当前节点，那么节点直接执行这个命令。</li>
<li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个 <code>MOVED</code> 错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令。</li>
</ul>
<h3 id="3-1-计算键属于哪个槽"><a href="#3-1-计算键属于哪个槽" class="headerlink" title="3.1 计算键属于哪个槽"></a>3.1 计算键属于哪个槽</h3><p>节点使用以下算法来计算给定键 <code>key</code> 属于哪个槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def slot_number(key):</span><br><span class="line">	return CRC16(key) &amp; 16383</span><br></pre></td></tr></table></figure>
<p>其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <code>CRC-16</code> 校验和，而 <code>&amp; 16383</code> 语句则用于计算出一个介于0 至 16383 之间的整数作为键 <code>key</code> 的槽号。</p>
<p>使用 <code>CLUSTER KEYSLOT &lt;key&gt;</code> 命令可以查看一个给定键属于哪个槽，以下是该命令的伪代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def CLUSTER_KEYSLOT(key)</span><br><span class="line">	</span><br><span class="line">	# 计算槽号</span><br><span class="line">	slot = slot_number(key)</span><br><span class="line">	</span><br><span class="line">	# 将槽号返回给客户端</span><br><span class="line">	reply_client(slot)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-判断槽是否由当前节点负责处理"><a href="#3-2-判断槽是否由当前节点负责处理" class="headerlink" title="3.2 判断槽是否由当前节点负责处理"></a>3.2 判断槽是否由当前节点负责处理</h3><p>当节点计算出键所属的槽 <code>i</code> 之后，节点就会检查自己在 <code>clusterState.slots</code> 数组中的项 <code>i</code>，判断键所在的槽是否由自己负责：</p>
<ol>
<li>如果 <code>clusterState.slots[i]</code> 等于 <code>clusterState.myself</code>，那么说明槽 <code>i</code> 由当前节点负责，节点可以执行客户端发送的命令。</li>
<li>如果 <code>clusterState.slots[i]</code> 不等于 <code>clusterState.myself</code>，那么说明槽 <code>i</code> 并非由当前节点负责，节点会根据 <code>clusterState.slots[i]</code> 指向的 <code>clusterNode</code> 结构所记录的节点 IP 和端口，向客户端返回 <code>MOVED</code> 错误，指引客户端转向至正在处理槽 <code>i</code> 的节点。</li>
</ol>
<h3 id="3-3-MOVED-错误"><a href="#3-3-MOVED-错误" class="headerlink" title="3.3 MOVED 错误"></a>3.3 MOVED 错误</h3><p>当节点发现键所在的槽并非由自己负责处理时，节点会向客户端返回一个 <code>MOVED</code> 错误，指引客户端转向至正在负责槽的节点，<code>MOVED</code> 错误的格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>slot</code> 为键所在的槽，而 <code>ip</code> 和 <code>port</code> 则是负责处理槽 <code>slot</code> 的节点的 IP 地址和端口号。</p>
<p>当客户端接收到节点返回的 <code>MOVED</code> 错误时，客户端会根据 <code>MOVED</code> 错误中提供的 IP 地址和端口号，转向至负责处理槽 <code>slot</code> 的节点，并向该节点重新发送之前想要执行的命令。</p>
<p>一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是换一个套接字来发送命令。</p>
<p>如果客户端尚未与想要转向的节点创建套接字连接，那么客户端会现根据 <code>MOVED</code> 错误提供的 IP 地址和端口号来连接节点，然后再进行转向。</p>
<p>集群模式的 <code>redis-cli</code> 客户端在接收到 <code>MOVED</code> 错误时，并不会打印出 <code>MOVED</code> 错误，而是根据 <code>MOVED</code> 错误自动进行节点跳转，并打印出转向信息，所以我们是看不见节点返回的 <code>MOVED</code> 错误的。</p>
<p>但是，如果我们使用单机（stand alone）模式的 <code>redis-cli</code> 客户端，再次向节点发送相同的命令，那么 <code>MOVED</code> 错误就会被客户端打印出来。这是因为单机模式的 <code>redis-cli</code> 客户端不清楚 <code>MOVED</code> 错误的作用，所以它只会直接将 <code>MOVED</code> 错误直接打印出来，而不会进行自动转向。</p>
<h3 id="3-4-节点数据库的实现"><a href="#3-4-节点数据库的实现" class="headerlink" title="3.4 节点数据库的实现"></a>3.4 节点数据库的实现</h3><p>节点和单机服务器在数据库方面的一个区别是，节点只能使用 0 号数据库，而单机 Redis 服务器则没有这一限制。</p>
<p>另外，除了将键值对保存在数据库里面之外，节点还会用 <code>clusterState</code> 结构中的 <code>slots_to_keys</code> 跳跃表来保存键和槽之间的关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typdef <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line"> 	zskiplist *slots_to_keys;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p><code>slots_to_keys</code> 跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键：</p>
<ul>
<li>每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到 <code>slots_to_keys</code> 跳跃表。</li>
<li>当节点删除数据库中的某个键值对时，节点就会在 <code>slots_to_keys</code> 跳跃表解除被删除键与槽号的关联。</li>
</ul>
<p>通过在 <code>slots_to_keys</code> 跳跃表中记录各个数据库键所属的槽，节点可以很方便地对属于某个或某些槽的所有数据库键进行批量操作。</p>
<h2 id="4-重新分片"><a href="#4-重新分片" class="headerlink" title="4. 重新分片"></a>4. 重新分片</h2><p>Redis 集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。 </p>
<p>重新分片操作可以在线（online）进行，在重新分片过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p>
<p>Redis 集群的重新分片操作由 Redis 的集群管理软件 redis-trib 负责执行，Redis 提供了进行重新分片所需的所有命令，而 redis-trib 则通过向源节点和目标节点发送命令来进行重新分片操作。</p>
<p>redis-trib 对集群的单个槽 slot 进行重新分片的步骤如下：</p>
<ol>
<li>redis-trib 对目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，让目标节点准备好从源节点导入（import）属于槽 <code>slot</code> 的键值对。</li>
<li><code>redis-trib</code> 对源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让源节点准备好将属于槽 <code>slot</code> 的键值对迁移（migrate）至目标节点。</li>
<li><code>redis-trib</code> 向源节点发送 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令，获得最多 <code>count</code> 个属于槽 <code>slot</code> 的键值对的键名。</li>
<li>对于步骤 3 获得的每个键名，redis-trib 都向源节点发送一个 <code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code> 命令，将被选中的键原子地从源节点迁移至目标节点。</li>
<li>重复执行步骤 3 和步骤 4，直到源节点保存的所有属于槽 <code>slot</code> 的键值对都被迁移至目标节点为止。</li>
<li>redis-trib 向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code> 命令，将槽 <code>slot</code> 指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽 <code>slot</code> 已经被指派给了目标节点。</li>
</ol>
<p>如果重新分片涉及多个槽，那么 redis-trib 将对每个给定的槽分别执行上面给出的步骤。</p>
<h2 id="5-ASK-错误"><a href="#5-ASK-错误" class="headerlink" title="5. ASK 错误"></a>5. ASK 错误</h2><p>在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。</p>
<p>当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：</p>
<ul>
<li>源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令</li>
<li>相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个 <code>ASK</code> 错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。</li>
</ul>
<h3 id="5-1-CLUSTER-SETSLOT-IMPORTING-命令的实现"><a href="#5-1-CLUSTER-SETSLOT-IMPORTING-命令的实现" class="headerlink" title="5.1 CLUSTER SETSLOT IMPORTING 命令的实现"></a>5.1 CLUSTER SETSLOT IMPORTING 命令的实现</h3><p><code>clusterState</code> 结构的 <code>importing_slots_from</code> 数组记录了当前节点正在从其他节点导入的槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line">	</span><br><span class="line">	// ...</span><br><span class="line">	</span><br><span class="line">	clusterNode *importing_slots_from[16384]</span><br><span class="line">	</span><br><span class="line">	// ...</span><br><span class="line">	</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p>如果 <code>importing_slots_from[i]</code> 的值不为 NULL，而是指向一个 <code>clusterNode</code> 结构，那么表示当前节点正在从 <code>clusterNode</code> 所代表的节点导入槽 <code>i</code>。</p>
<p>在对集群进行重新分片的时候，向目标节点发送命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 可以将目标节点 <code>clusterState.importing_slots_from[i]</code> 的值设置为 <code>source_id</code> 所代表节点的 <code>clusterNode</code> 结构。</p>
<h3 id="5-2-CLUSTER-SETSLOT-MIGRATING-命令的实现"><a href="#5-2-CLUSTER-SETSLOT-MIGRATING-命令的实现" class="headerlink" title="5.2 CLUSTER SETSLOT MIGRATING 命令的实现"></a>5.2 CLUSTER SETSLOT MIGRATING 命令的实现</h3><p><code>clusterState</code> 结构的 <code>migrating_slots_to</code> 数组记录了当前节点正在迁移至其他节点的槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line">	</span><br><span class="line">	// ...</span><br><span class="line">	</span><br><span class="line">	clusterNode *migrating_slots_to[16384]</span><br><span class="line">	</span><br><span class="line">	// ...</span><br><span class="line">	</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p>如果 <code>migrating_slots_to[i]</code> 的值不为 NULL，而是指向一个 <code>clusterNode</code> 结构，那么表示当前节点正在将槽 <code>i</code> 迁移至 <code>clusterNode</code> 所代表的节点。</p>
<p>在对集群进行重新分片的时候，向源节点发送命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</span><br></pre></td></tr></table></figure>
<p> 可以将源节点 <code>clusterState.migrating_slots_to[i]</code> 的值设置为 <code>target_id</code> 所代表节点的 <code>clusterNode</code> 结构。</p>
<h3 id="5-3-ASK-错误"><a href="#5-3-ASK-错误" class="headerlink" title="5.3 ASK 错误"></a>5.3 ASK 错误</h3><p>如果节点收到一个关于键 <code>key</code> 的命令请求，并且键 <code>key</code> 所属的槽 <code>i</code> 正好就指派给了这个节点，那么节点会尝试在自己的数据库里查找键 <code>key</code>，如果找到了的话，节点就直接执行客户端发送的命令。</p>
<p>与此相反，如果节点没有在自己的数据库里找到键 <code>key</code>，那么节点会检查自己的 <code>clusterState.migrating_slots_to[i]</code>，看键 <code>key</code> 所属的槽 <code>i</code> 是否正在进行迁移，如果槽 <code>i</code> 的确在进行迁移的话，那么节点会向客户端发送一个 <code>ASK</code> 错误，引导客户端到正在导入槽 <code>i</code> 的节点去超找键 <code>key</code>。</p>
<p>接到 <code>ASK</code> 错误的客户端会根据错误提供的 IP 和端口号，转向至正在导入槽的目标节点，然后首先向目标节点发送一个 <code>ASKING</code> 命令，之后再重新发送原本想要执行的命令。</p>
<h3 id="5-4-ASKING-命令"><a href="#5-4-ASKING-命令" class="headerlink" title="5.4 ASKING 命令"></a>5.4 ASKING 命令</h3><p><code>ASKING</code> 命令唯一要做的就是打开发送该命令的客户端的 <code>REDIS_ASKING</code> 标识，以下是该命令的伪代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def ASKING():</span><br><span class="line"></span><br><span class="line">	# 打开标识</span><br><span class="line">	client.flags != REDIS_ASKING</span><br><span class="line">	</span><br><span class="line">	# 向客户端发送 OK 回复</span><br><span class="line">	reply(&quot;OK)</span><br></pre></td></tr></table></figure>
<p>在一般情况下，如果客户端向节点发送一个关于槽 <code>i</code> 的命令，而槽 <code>i</code> 又没有指派给这个节点的话，那么节点将向客户端返回一个 <code>MOVED</code> 错误；但是，如果节点的 <code>clusterState.importing_slots_from[i]</code> 显示节点正在导入槽 <code>i</code>， 并且发送命令的客户端带有 <code>REDIS_ASKING</code> 标识，那么节点将破例执行这个关于槽 <code>i</code> 的命令一次。</p>
<p>当客户端接收到 <code>ASK</code> 错误并转向至正在导入槽的节点时，客户端会先向节点发送一个 <code>ASKING</code> 命令，然后才重新发送想要执行的命令，这是因为如果客户端不发送 <code>ASKING</code> 命令，而直接发送想要执行的命令的话，那么客户端发送的命令将被节点拒绝执行，并返回 <code>MOVED</code> 错误。</p>
<p>另外要注意的是，客户端的 <code>REDIS_ASKING</code> 标识是一个一次性标识，当节点执行了一个带有 <code>REDIS_ASKING</code> 标识的客户端发送的命令之后，客户端的 <code>REDIS_ASKING</code> 标识就会被移除。</p>
<h3 id="5-5-ASK-错误和-MOVED-错误的区别"><a href="#5-5-ASK-错误和-MOVED-错误的区别" class="headerlink" title="5.5 ASK 错误和 MOVED 错误的区别"></a>5.5 ASK 错误和 MOVED 错误的区别</h3><p><code>ASK</code> 错误和 <code>MOVED</code> 错误都会导致客户端转向，它们的区别在于：</p>
<ul>
<li><code>MOVED</code> 错误代表槽的负责权已经从一个节点转移到了另一个节点：客户端收到关于槽 <code>i</code> 的 <code>MOVED</code> 错误之后，客户端每次收到关于槽 <code>i</code> 的命令请求时，都可以直接将命令请求发送至 <code>MOVED</code> 错误所指向的节点，因为该节点就是目前负责处理槽 <code>i</code> 的节点。</li>
<li>与此相反，<code>ASK</code> 错误只是两个节点在迁移槽的过程中使用的一种临时措施：在客户端收到关于槽 <code>i</code> 的 <code>ASK</code> 错误之后，客户端只会在接下来的一次命令请求中将关于槽 <code>i</code> 的命令请求发送至 <code>ASK</code> 错误所指向的节点，但这种转向不会对客户端今后发送关于槽 <code>i</code> 的命令请求产生任何影响，客户端仍然会将关于槽 <code>i</code> 的命令请求发送至目前负责处理槽 <code>i</code> 的节点，除非 <code>ASK</code> 错误再次出现。</li>
</ul>
<h2 id="6-复制与故障迁移"><a href="#6-复制与故障迁移" class="headerlink" title="6. 复制与故障迁移"></a>6. 复制与故障迁移</h2><p>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<h3 id="6-1-设置从节点"><a href="#6-1-设置从节点" class="headerlink" title="6.1 设置从节点"></a>6.1 设置从节点</h3><p>向一个节点发送命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt;</span><br></pre></td></tr></table></figure>
<p>可以让接收命令的节点成为 <code>node_id</code> 所指定节点的从节点，并开始对主节点进行复制：</p>
<ul>
<li><p>接收到该命令的节点首先会在自己的  <code>clusterState.nodes</code> 字典里找到 <code>node_id</code> 所对应节点的 <code>clusterNode</code> 结构，并将自己的 <code>clusterState.myself.slaveof</code> 指针指向这个结构，以此来记录这个节点正在复制的主节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果这是一个从节点，那么指向主节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后节点会修改自己在 <code>clusterState.myself.flags</code> 中的属性，关闭原本的 <code>REDIS_NODE_MASTER</code> 标识，打开 <code>REDIS_NODE_SLAVE</code> 标识，表示这个节点已经由原来的主节点变成了从节点。</p>
</li>
<li><p>最后，节点会调用复制代码，并根据 <code>clusterState.myself.slaveof</code> 指向的 <code>clusterNode</code> 结构所保存的 IP 地址和端口号，对主节点进行复制。因为节点的复制功能和单机 Redis 服务器的复制功能使用了相同的代码，所以让从节点复制主节点相当于向从节点发送命令 <code>SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</code>。</p>
</li>
</ul>
<p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点。</p>
<p>集群中的所有节点都会在代表主节点的 <code>clusterNode</code> 结构的 <code>slaves</code> 属性和 <code>numslaves</code> 属性中记录正在复制这个主节点的从节点名单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 正在复制这个主节点的从节点数量</span></span><br><span class="line">	<span class="keyword">int</span> numslaves;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一个数组</span></span><br><span class="line">	<span class="comment">// 每个数组项指向一个正在复制这个主节点的从节点的 clusterNode 结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-故障检测"><a href="#6-2-故障检测" class="headerlink" title="6.2 故障检测"></a>6.2 故障检测</h3><p>集群中的每个节点都会定期地向集群中的其他节点发送 <code>PING</code> 消息，以此来检测对方是否在线，如果接收 <code>PING</code> 消息的节点没有在规定的时间内，向发送 <code>PING</code> 消息的节点返回 <code>PONG</code> 消息，那么发送 <code>PING</code> 消息的节点就会将接收 <code>PING</code> 消息的节点标记为疑似下线（probable fail，PFAIL）。</p>
<p>集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息。</p>
<p>当一个主节点 A 通过消息得知主节点 B 认为主节点 C 进入了疑似下线状态时，主节点 A 会在自己的 <code>clusterState.nodes</code> 字典中找到主节点 C 所对应的 <code>clusterNode</code> 结构，并将主节点 B 的下线报告（failure report）添加到 <code>clusterNode</code> 结构的 <code>fail_reports</code> 链表里面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 一个链表，记录了所有其他节点对该节点的下线报告</span></span><br><span class="line">	<span class="built_in">list</span> *fail_reports;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个下线报告由一个 <code>clusterNodeFailReport</code> 结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 报告目标节点已经下线的节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最后一次从 node 节点收到下线报告的时间</span></span><br><span class="line">	<span class="comment">// 程序使用这个时间戳来检查下线报告是否过期</span></span><br><span class="line">	<span class="comment">// (与当前时间差太久的下线报告会被删除)</span></span><br><span class="line">	<span class="keyword">mstime_t</span> time;</span><br><span class="line">&#125; <span class="keyword">typedef</span> clusterNodeFailReport;</span><br></pre></td></tr></table></figure>
<p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点 x 报告为疑似下线，那么这个主节点 x 将被标记为已下线（FAIL），将主节点 x 标记为已下线的节点会向集群广播一条关于主节点 x 的 <code>FAIL</code> 消息，所有收到这条 <code>FAIL</code> 消息的节点都会立即将主节点 x 标记为已下线。</p>
<h3 id="6-3-故障转移"><a href="#6-3-故障转移" class="headerlink" title="6.3 故障转移"></a>6.3 故障转移</h3><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li>
<li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。 </li>
<li>新的主节点向集群广播一条 <code>PONG</code> 消息，这条 <code>PONG</code> 消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<h3 id="6-4-选举新的主节点"><a href="#6-4-选举新的主节点" class="headerlink" title="6.4 选举新的主节点"></a>6.4 选举新的主节点</h3><p>新的主节点是通过选举产生的，以下是集群选举新的主节点的方法：</p>
<ol>
<li>集群的配置纪元是一个自增计数器，它的初始值为 0。</li>
<li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li>
<li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>
<li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会想集群广播一条 <code>CLUSTER_TYPE_FAILOVER_AUTH_REQUEST</code> 消息，要求所有接收到这条消息、并且具有投票权的主节点向这个从节点投票。</li>
<li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code> 消息，表示这个主节点支持从节点成为新的主节点。</li>
<li>每个参与选举的从节点都会接收 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code> 消息，并根据自己收到了多少条这种消息来同济自己获得了多少主节点的支持。</li>
<li>如果集群里有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于 N/2+1 张支持票时，这个从节点就会当选为新的主节点。</li>
<li>因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有 N 个主节点进行投票，那么具有大于等于 N/2+1 张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li>
<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，知道选出新的主节点为止。</li>
</ol>
<h2 id="7-消息"><a href="#7-消息" class="headerlink" title="7. 消息"></a>7. 消息</h2><p>集群中的各个节点通过发送和接收消息（message）来进行通信，我们称发送消息的节点为发送者（sender），接收消息的节点为接收者（receiver）。节点发送的消息主要有以下五种：</p>
<ul>
<li><code>MEET</code> 消息：当发送者接到客户端发送的 <code>CLUSTER MEET</code> 命令时，发送者会向接收者发送 <code>MEET</code> 消息， 请求接收者加入到发送者当前所处的集群里面。</li>
<li><code>PING</code> 消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过 <code>PING</code> 消息的节点发送 <code>PING</code> 消息，以此来检测被选中的节点是否在线。除此以外，如果节点 A 最后一次收到节点 B 发送的 <code>PONG</code> 消息的时间，距离当前时间已经超过了节点 A 的 <code>cluster-node-timeout</code> 选项设置时长的一半，那么节点 A 也会向节点 B 发送 <code>PING</code> 消息，这可以防止节点 A 因为长时间没有随机选中节点 B 作为 <code>PING</code> 消息的发送对象而导致对节点 B 的信息更新滞后。</li>
<li><code>PONG</code> 消息：当接收者收到发送者发来的 <code>MEET</code> 消息或者 <code>PING</code> 消息时，为了向发送者确认这条 <code>MEET</code> 消息或者 <code>PING</code> 消息已到达，接收者会向发送者返回一条 <code>PONG</code> 消息。另外，一个节点也可以通过向集群广播 <code>PONG</code> 消息来让集群中的其他节点立即刷新关于这个节点的认识，例如当一次故障转移操作成功之后，新的主节点会向集群广播一条 <code>PONG</code> 消息，以此来让集群中的其他节点立即知道这个节点已经变成了主节点，并且接管了已下线节点负责的槽。</li>
<li><code>FAIL</code> 消息：当一个主节点 A 判断另一个主节点 B 已经进入 <code>FAIL</code> 状态时，节点 A 会向集群广播一条关于节点 B 的 <code>FAIL</code> 消息，所有收到这条消息的节点都会立即将节点 B 标记为已下线。</li>
<li><code>PUBLISH</code> 消息：当节点收到一个 <code>PUBLISH</code> 命令时，节点会执行这个命令，并向集群广播一条 <code>PUBLISH</code> 消息，所有接收到这条 <code>PUBLISH</code> 消息的节点都会执行相同的 <code>PUBLISH</code> 命令。</li>
</ul>
<p>一条消息由消息头（header）和消息正文（data）组成。</p>
<h3 id="7-1-消息头"><a href="#7-1-消息头" class="headerlink" title="7.1 消息头"></a>7.1 消息头</h3><p>节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些信息，因为这些信息也会被消息接受者用到，所以严格来讲，我们可以认为消息头本身也是消息的一部分。</p>
<p>每个消息头都由一个<code>cluster.h/clusterMsg</code>结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 消息的长度，包括消息头和消息正文</span></span><br><span class="line">  <span class="keyword">uint32_t</span> totlen;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 消息的类型</span></span><br><span class="line">  <span class="keyword">uint16_t</span> type;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 消息正文包含的节点信息数量</span></span><br><span class="line">  <span class="comment">// 只在发送MEET、PING、PONG这三种Gossip协议的消息时使用</span></span><br><span class="line">  <span class="keyword">uint16_t</span> count;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送者所处的配置纪元</span></span><br><span class="line">  <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果发送者是一个master，那么这里记录的是发送者的配置纪元</span></span><br><span class="line">  <span class="comment">// 如果发送者是一个slave，那么这里记录的是发送者正在复制的master的配置纪元</span></span><br><span class="line">  <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送者的名字(ID)</span></span><br><span class="line">  <span class="keyword">char</span> sender[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送者目前的槽指派信息</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> myslots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果发送者是一个slave，那么这里记录的是它正在复制的master的名字</span></span><br><span class="line">  <span class="comment">// 如果发送者是一个master，那么这里记录的是REDIS_NODE_NULL_NAME</span></span><br><span class="line">  <span class="keyword">char</span> slaveof[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送者的端口号</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送者的标识值</span></span><br><span class="line">  <span class="keyword">uint16_t</span> flags;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发送者所处集群的状态</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> state;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 消息的正文</span></span><br><span class="line">  <span class="keyword">union</span> clusterMsgData data;</span><br><span class="line">&#125; cllusterMsg;</span><br></pre></td></tr></table></figure>
<p><code>clusterMsg.data</code> 属性指向联合体 <code>cluster.h/clusterMsgData</code>，这个联合体就是消息的正文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> clusterMsgData &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 每条 MEET、PING、PONG 消息都包含两个 clusterMsgDataGossip 结构</span></span><br><span class="line">    clusterMsgDataGossip[<span class="number">1</span>];</span><br><span class="line">  &#125; ping;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// FAIL 消息的正文</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    clusterMsgDataFail about;</span><br><span class="line">  &#125; fail;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// PUBLISH 消息的正文</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    clusterMsgDataPublish msg;</span><br><span class="line">  &#125; publish;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>clusterMsg</code> 结构的 <code>currentEpoch</code>、<code>sender</code>、<code>myslots</code> 等属性记录了发送者的节点信息，接收者可以根据这些信息，在自己的 <code>clusterState.nodes</code>字典中找到发送者对应的 <code>clusterNode</code> 结构进行更新。</p>
<h3 id="7-2-MEET、PING、PONG-消息的实现"><a href="#7-2-MEET、PING、PONG-消息的实现" class="headerlink" title="7.2 MEET、PING、PONG 消息的实现"></a>7.2 MEET、PING、PONG 消息的实现</h3><p>Redis 集群中的各个节点通过 Gossip 协议来交换节点的状态信息，其中 Gossip 协议由 <code>MEET</code>、<code>PING</code>、<code>PONG</code> 三种消息实现，这三种消息的正文都是由两个 <code>cluster.h/clusterMsgDataGossip</code> 结构组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 节点的名字</span></span><br><span class="line">  <span class="keyword">char</span> nodename[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最后一次向该节点发送 PING 消息的时间戳</span></span><br><span class="line">  <span class="keyword">uint32_t</span> ping_sent;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最后一次从该节点接收到 PONG 消息的时间戳</span></span><br><span class="line">  <span class="keyword">uint32_t</span> pong_received;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 节点的IP</span></span><br><span class="line">  <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 节点的端口</span></span><br><span class="line">  <span class="keyword">uint16_t</span> port;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 节点的标识符</span></span><br><span class="line">  <span class="keyword">uint16_t</span> flags;</span><br><span class="line">&#125; clusterMsgDataGossip;</span><br></pre></td></tr></table></figure>
<p>因为 <code>MEET</code>、<code>PING</code>、<code>PONG</code> 三种消息都是用相同的消息正文，所以节点通过消息头的 <code>type</code> 属性来判断一条消息是 <code>MEET</code>消息、<code>PING</code> 消息还是 <code>PONG</code> 消息。</p>
<p>每次发送 <code>MEET</code>、<code>PING</code>、<code>PONG</code> 消息时，发送者从自己的已知节点中随机选出两个节点（可以是主节点或从节点），并将这两个被选中的节点的信息分别保存到两个 <code>cluster.h/clusterMsgDataGossip</code> 结构里面。</p>
<p><code>clusterMsgDataGossip</code> 结构记录了被选中的节点的名字、发送者与被选中节点最后一次发送和接收 <code>PING</code> 和 <code>PONG</code> 消息的时间戳，被选中节点的 IP 地址和端口号，以及被选中节点的标识值。</p>
<p>当接收者收到 <code>MEET</code>、<code>PING</code>、<code>PONG</code> 消息时，接收者会访问消息正文中的两个 <code>clusterMsgDataGossip</code> 结构，并根据自己是否认识 <code>clusterMsgDataGossip</code> 记录的被选中节点来选择进行哪种操作：</p>
<ul>
<li>如果被选中节点不存在于接收者的已知节点列表，那么说明接收者是第一次接触到被选中节点，接收者将根据结构中记录的 IP 地址和端口号等信息，与被选中节点进行握手。</li>
<li>如果被选中节点存在于接收者的已知节点列表，那么说明接收者之前已经与被选中节点进行过接触，接收者将根据 <code>clusterMsgDataGossip</code> 结构记录的信息，对被选中的节点所对应的 <code>clusterNode</code> 结构进行更新。</li>
</ul>
<h3 id="7-3-FAIL-消息的实现"><a href="#7-3-FAIL-消息的实现" class="headerlink" title="7.3 FAIL 消息的实现"></a>7.3 FAIL 消息的实现</h3><p>当集群里的主节点 A 将主节点 B 标记为已下线时（FAIL）时，主节点 A 将向集群广播一条关于主节点 B 的 <code>FAIL</code> 消息，所有接收到这条 <code>FAIL</code> 消息的节点都会将主节点 B 标记为已下线。</p>
<p><code>FAIL</code> 消息的正文由 <code>cluster.h/clusterMsgDataFail</code> 结构表示，这个结构只包含一个 <code>nodeName</code> 属性，该属性记录了已下线节点的名字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> nodename[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">&#125; clusterMsgDataFail;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-PUBLISH-消息的实现"><a href="#7-4-PUBLISH-消息的实现" class="headerlink" title="7.4 PUBLISH 消息的实现"></a>7.4 PUBLISH 消息的实现</h3><p>当客户端向集群中的某个节点发送命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>的时候，接收到 <code>PUBLISH</code> 命令的节点不仅会向 <code>channel</code> 频道发送消息 <code>message</code>，它还会向集群广播一条 <code>PUBLISH</code> 消息，所有接收到这条 <code>PUBLISH</code> 消息的节点都会向 <code>channnel</code> 频道发送 <code>message</code> 消息。</p>
<p><code>PUBLISH</code> 消息的正文由 <code>cluster.h/clusterMsgDataPublish</code> 结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uint32_t</span> channel_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> message_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义为 8 字节只是为了对齐其他消息结构</span></span><br><span class="line">	<span class="comment">// 实际的长度由保存的内容决定</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> bulk_data[<span class="number">8</span>];</span><br><span class="line">  </span><br><span class="line">&#125; clusterMsgDataPublish;</span><br></pre></td></tr></table></figure>
<p><code>clusterMsgDataPublish</code> 结构的 <code>bulk_data</code> 属性是一个字节数组，这个字节数组保存了客户端通过 <code>PUBLISH</code> 命令发送给节点的 <code>channel</code> 参数和 <code>message</code> 参数，而结构的 <code>channel_len</code> 和 <code>message_len</code> 则分别保存了 <code>channel</code> 参数的长度和 <code>message</code> 参数的长度：</p>
<ul>
<li>其中 <code>bulk_data</code> 的 0 字节至 channel_len - 1 字节保存的是 <code>channel</code> 参数。</li>
<li>而 <code>bulk_data</code> 的 channel_len 字节至 channel_len + message_len - 1 字节保存的是 <code>message</code> 参数。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/Database/" rel="tag"># Database</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/06/《Redis-设计与实现：服务器》/" rel="next" title="《Redis 设计与实现：服务器》">
                <i class="fa fa-chevron-left"></i> 《Redis 设计与实现：服务器》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/08/《Redis-设计与实现：复制》/" rel="prev" title="《Redis 设计与实现：复制》">
                《Redis 设计与实现：复制》 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Yongqiang Xiang" />
          <p class="site-author-name" itemprop="name">Yongqiang Xiang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">66</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiangyq000" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://stackoverflow.com/users/4945225/xiangyq000" target="_blank" title="StackOverflow">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                    
                      StackOverflow
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-节点"><span class="nav-number">1.</span> <span class="nav-text">1. 节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-启动节点"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 启动节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-集群数据结构"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 集群数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-CLUSTER-MEET-命令的实现"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 CLUSTER MEET 命令的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-槽指派"><span class="nav-number">2.</span> <span class="nav-text">2. 槽指派</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-记录节点的槽指派信息"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 记录节点的槽指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-传播节点的槽指派信息"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 传播节点的槽指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-记录集群所有槽的指派信息"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 记录集群所有槽的指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-CLUSTER-ADDSLOTS命令的实现"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 CLUSTER ADDSLOTS命令的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-在集群中执行命令"><span class="nav-number">3.</span> <span class="nav-text">3. 在集群中执行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-计算键属于哪个槽"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 计算键属于哪个槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-判断槽是否由当前节点负责处理"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 判断槽是否由当前节点负责处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-MOVED-错误"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 MOVED 错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-节点数据库的实现"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 节点数据库的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-重新分片"><span class="nav-number">4.</span> <span class="nav-text">4. 重新分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-ASK-错误"><span class="nav-number">5.</span> <span class="nav-text">5. ASK 错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-CLUSTER-SETSLOT-IMPORTING-命令的实现"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 CLUSTER SETSLOT IMPORTING 命令的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-CLUSTER-SETSLOT-MIGRATING-命令的实现"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 CLUSTER SETSLOT MIGRATING 命令的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-ASK-错误"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 ASK 错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-ASKING-命令"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 ASKING 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-ASK-错误和-MOVED-错误的区别"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 ASK 错误和 MOVED 错误的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-复制与故障迁移"><span class="nav-number">6.</span> <span class="nav-text">6. 复制与故障迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-设置从节点"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 设置从节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-故障检测"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 故障检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-故障转移"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-选举新的主节点"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 选举新的主节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-消息"><span class="nav-number">7.</span> <span class="nav-text">7. 消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-消息头"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 消息头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-MEET、PING、PONG-消息的实现"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 MEET、PING、PONG 消息的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-FAIL-消息的实现"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 FAIL 消息的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-PUBLISH-消息的实现"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 PUBLISH 消息的实现</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yongqiang Xiang</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->





  

  

  

  

  

  

</body>
</html>
